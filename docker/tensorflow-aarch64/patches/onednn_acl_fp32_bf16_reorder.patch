 *******************************************************************************
 Copyright 2023 Arm Limited and affiliates.
 SPDX-License-Identifier: Apache-2.0

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 *******************************************************************************
diff --git a/include/oneapi/dnnl/dnnl.hpp b/include/oneapi/dnnl/dnnl.hpp
index 5a2b94314c..474aa8986b 100644
--- a/include/oneapi/dnnl/dnnl.hpp
+++ b/include/oneapi/dnnl/dnnl.hpp
@@ -1176,6 +1176,8 @@ struct memory : public handle<dnnl_memory_t> {
         AB16b32a2b = dnnl_AB16b32a2b,
         AB16b48a2b = dnnl_AB16b48a2b,
         AB16b64a2b = dnnl_AB16b64a2b,
+        Ab4a = dnnl_Ab4a,
+        Ab8a = dnnl_Ab8a,
         Abc16a = dnnl_Abc16a,
         ABc16a16b = dnnl_ABc16a16b,
         ABc4a4b = dnnl_ABc4a4b,
@@ -2272,6 +2274,8 @@ struct memory : public handle<dnnl_memory_t> {
         aCB16c4b = dnnl_aCB16c4b,
         BA16b2a = dnnl_BA16b2a,
         BA16b4a = dnnl_BA16b4a,
+        BA4b4a = dnnl_BA4b4a,
+        BA8b4a = dnnl_BA8b4a,
         aBC16b16c = dnnl_aBC16b16c,
         aBC16b32c = dnnl_aBC16b32c,
         AB16a16b = dnnl_AB16a16b,
diff --git a/include/oneapi/dnnl/dnnl_types.h b/include/oneapi/dnnl/dnnl_types.h
index 3860754101..5c99c7adec 100644
--- a/include/oneapi/dnnl/dnnl_types.h
+++ b/include/oneapi/dnnl/dnnl_types.h
@@ -221,7 +221,8 @@ typedef enum {
     dnnl_abcdefghijlk, ///< permuted 12D tensor
 
     // Opaque blocked formats
-
+    dnnl_Ab4a,
+    dnnl_Ab8a,
     dnnl_Abc16a,
     dnnl_ABc16a16b,
     dnnl_ABc32a32b,
@@ -702,6 +703,8 @@ typedef enum {
     dnnl_aCB16c4b,
     dnnl_BA16b2a,
     dnnl_BA16b4a,
+    dnnl_BA4b4a,
+    dnnl_BA8b4a,
     dnnl_aBC16b16c,
     dnnl_aBC16b32c,
     dnnl_AB16a16b,
diff --git a/src/common/c_types_map.hpp b/src/common/c_types_map.hpp
index 06f7a477b8..4c9be001ab 100644
--- a/src/common/c_types_map.hpp
+++ b/src/common/c_types_map.hpp
@@ -314,6 +314,8 @@ const format_tag_t AB16b16a2b = dnnl_AB16b16a2b;
 const format_tag_t AB16b32a2b = dnnl_AB16b32a2b;
 const format_tag_t AB16b48a2b = dnnl_AB16b48a2b;
 const format_tag_t AB16b64a2b = dnnl_AB16b64a2b;
+const format_tag_t BA4b4a = dnnl_BA4b4a;
+const format_tag_t BA8b4a = dnnl_BA8b4a;
 const format_tag_t BA16a16b = dnnl_BA16a16b;
 const format_tag_t BA16a32b = dnnl_BA16a32b;
 const format_tag_t BA16a48b = dnnl_BA16a48b;
@@ -339,6 +341,8 @@ const format_tag_t aCB16b32c4b = dnnl_aCB16b32c4b;
 const format_tag_t aCB16b48c4b = dnnl_aCB16b48c4b;
 const format_tag_t aCB16b64c4b = dnnl_aCB16b64c4b;
 
+const format_tag_t Ab4a = dnnl_Ab4a;
+const format_tag_t Ab8a = dnnl_Ab8a;
 const format_tag_t Abc16a = dnnl_Abc16a;
 const format_tag_t ABc16a16b = dnnl_ABc16a16b;
 const format_tag_t ABc4a2b = dnnl_ABc4a2b;
diff --git a/src/common/dnnl_debug_autogenerated.cpp b/src/common/dnnl_debug_autogenerated.cpp
index f4883c4cd4..57217a90f2 100644
--- a/src/common/dnnl_debug_autogenerated.cpp
+++ b/src/common/dnnl_debug_autogenerated.cpp
@@ -1567,10 +1567,15 @@ const char *dnnl_fmt_tag2str(dnnl_format_tag_t v) {
     if (v == dnnl_gOIdhw2o8i16o2i) return "gOIdhw2o8i16o2i";
     if (v == dnnl_gOIw2o8i16o4i) return "gOIw2o8i16o4i";
     if (v == dnnl_gOIhw2o8i16o4i) return "gOIhw2o8i16o4i";
+    if (v == dnnl_BA8b4a) return "BA8b4a";
+    if (v == dnnl_BA4b4a) return "BA4b4a";
+    if (v == dnnl_Ab4a) return "Ab4a";
+    if (v == dnnl_Ab8a) return "Ab8a";
     assert(!"unknown fmt_tag");
     return "unknown fmt_tag";
 }
 
+
 const char *dnnl_prop_kind2str(dnnl_prop_kind_t v) {
     if (v == dnnl_prop_kind_undef) return "undef";
     if (v == dnnl_forward_training) return "forward_training";
@@ -1734,5 +1739,3 @@ const char *dnnl_cpu_isa_hints2str(dnnl_cpu_isa_hints_t v) {
     assert(!"unknown cpu_isa_hints");
     return "unknown cpu_isa_hints";
 }
-
-
diff --git a/src/common/memory_desc_wrapper.cpp b/src/common/memory_desc_wrapper.cpp
index 1d19f2e349..7ca789a8b5 100644
--- a/src/common/memory_desc_wrapper.cpp
+++ b/src/common/memory_desc_wrapper.cpp
@@ -186,6 +186,12 @@ status_t memory_desc_wrapper::compute_blocking(
         C(Abc4a, {0, 1, 2}, {4}, {0});
         C(aBc4b, {0, 1, 2}, {4}, {1});
 
+        C(Ab4a, {0, 1}, {4}, {0});
+        C(Ab8a, {0, 1}, {8}, {0});
+
+        C(BA4b4a, {1, 0}, {4, 4}, {1, 0});
+        C(BA8b4a, {1, 0}, {8, 4}, {1, 0});
+
         C(BA16a16b, {1, 0}, {16, 16}, {0, 1});
         C(BA16a32b, {1, 0}, {16, 32}, {0, 1});
         C(BA16a48b, {1, 0}, {16, 48}, {0, 1});
diff --git a/src/cpu/aarch64/acl_reorder.hpp b/src/cpu/aarch64/acl_reorder.hpp
index edbc38914d..5b209dca2e 100644
--- a/src/cpu/aarch64/acl_reorder.hpp
+++ b/src/cpu/aarch64/acl_reorder.hpp
@@ -16,10 +16,11 @@
 #ifndef CPU_AARCH64_ACL_REORDER_HPP
 #define CPU_AARCH64_ACL_REORDER_HPP
 
-#include "cpu/aarch64/acl_utils.hpp"
-#include "cpu/reorder/cpu_reorder_pd.hpp"
 #include "arm_compute/core/Types.h"
 #include "common/utils.hpp"
+#include "cpu/aarch64/acl_utils.hpp"
+#include "cpu/aarch64/cpu_isa_traits.hpp"
+#include "cpu/reorder/cpu_reorder_pd.hpp"
 
 namespace dnnl {
 namespace impl {
@@ -42,7 +43,8 @@ struct acl_reorder_conf_t {
 };
 
 struct acl_reorder_resource_t : public resource_t {
-    acl_reorder_resource_t() : acl_obj_(utils::make_unique<acl_reorder_obj_t>()) {}
+    acl_reorder_resource_t()
+        : acl_obj_(utils::make_unique<acl_reorder_obj_t>()) {}
 
     status_t configure(const acl_reorder_conf_t &app) {
         if (!acl_obj_) return status::out_of_memory;
@@ -84,141 +86,184 @@ struct acl_reorder_fwd_t : public primitive_t {
                 const memory_desc_t *dst_md) {
 
             using namespace acl_utils;
-            // using skip_mask_t = dnnl_primitive_attr::skip_mask_t;
 
-            bool ok = src_md->data_type
-                            == dst_md->data_type // ACL only supports matching src/dst data types
-                    && utils::one_of(src_md->data_type,
-                            data_type::f32) // Only supports f32 for now
+            // ACL reorder support f32->f32 and f32->bf16
+            bool ok = src_md->data_type == data_type::f32
+                    && utils::one_of(
+                            dst_md->data_type, data_type::f32, data_type::bf16)
                     && attr->has_default_values();
+
             if (!ok) return status::unimplemented;
 
             int mask = -1;
             bool is_set = false;
-            // CHECK(attr->scales_.get(DNNL_ARG_DST, &mask, &is_set));
+            CHECK(attr->scales_.get(DNNL_ARG_DST, &mask, &is_set));
             const memory_desc_wrapper input_d(src_md);
             if (input_d.has_runtime_dims_or_strides() && is_set && mask > 0)
                 return status::unimplemented;
 
             // Create and check primitive descriptor
-            auto _pd = new pd_t(attr, src_engine->kind(), src_md,
+            auto _pd = make_unique_pd<pd_t>(attr, src_engine->kind(), src_md,
                     dst_engine->kind(), dst_md);
             if (_pd == nullptr) return status::out_of_memory;
             if (_pd->init(engine, src_engine, dst_engine) != status::success) {
-                delete _pd;
                 return status::unimplemented;
             }
 
-            const memory_desc_wrapper src_d(*src_md);
-            const memory_desc_wrapper dst_d(*dst_md);
-
-            const int ndims = src_d.ndims();
-
-            auto src_tag = memory_desc_matches_one_of_tag(
-                            *src_md, format_tag::ba, format_tag::cdba);
-            ACL_CHECK_SUPPORT(
-                            utils::one_of(format_tag::undef, src_tag),
-                            "");
-
             arm_compute::TensorShape acl_tensor_shape_in;
             arm_compute::TensorShape acl_tensor_shape_out;
-            // Need even amount of dims in dim 0 for ACL kernel (eg mulitple of 8 rows when blocking by 8)
-            int dim_0_rounded_up;
-
-            // Switch for 2 or 4 dim tensors
-            switch(ndims)
-            {
-                // Currently for Ab4a and Ab8a
-                // No format_tag for these, have to deduce from stride
-                case 2:
-                    {
-                        if(dst_md->dims[0] == 1 || dst_md->dims[1] == 1){
-                            return status::unimplemented;
-                        }
-                        int dst_dim_1 = dst_md->dims[1];
-                        int dst_dim_0_stride = dst_md->format_desc.blocking.strides[0];
-                        int dst_dim_1_stride = dst_md->format_desc.blocking.strides[1];
-                        // Interleave of 4 or 8 that stride for dim 1
-                        if (dst_dim_1_stride != 4 && dst_dim_1_stride != 8){
-                            return status::unimplemented;
-                        }
-                        // Check to ensure it's a blocking transpose
-                        if (dst_dim_1 * dst_dim_1_stride != dst_dim_0_stride){
+
+            // f32 to bf16 reorder
+            if (src_md->data_type == data_type::f32
+                    && dst_md->data_type == data_type::bf16) {
+
+                if (dst_md->dims[0] == 1 || dst_md->dims[1] == 1) {
+                    return status::unimplemented;
+                }
+
+                auto src_tag = memory_desc_matches_one_of_tag(
+                        *src_md, format_tag::ab);
+                ACL_CHECK_SUPPORT(utils::one_of(format_tag::undef, src_tag),
+                        "Only ab source formats supported");
+
+                auto dst_tag = memory_desc_matches_one_of_tag(
+                        *dst_md, format_tag::BA8b4a, format_tag::BA4b4a);
+                ACL_CHECK_SUPPORT(utils::one_of(format_tag::undef, dst_tag),
+                        "Only BA8b4a and BA4b4a destination formats supported");
+
+                if (dst_tag == format_tag::BA4b4a) {
+                    // Set Dest WeightFormat
+                    _pd->app_.dst_wf = arm_compute::WeightFormat::OHWIo4;
+                    // Blocking for BA8b4a only supported with SVE length 256
+                } else if (dst_tag == format_tag::BA8b4a && mayiuse(sve_256)) {
+                    // Set Dest WeightFormat
+                    _pd->app_.dst_wf = arm_compute::WeightFormat::OHWIo8;
+                } else {
+                    return status::unimplemented;
+                }
+
+                acl_tensor_shape_in = arm_compute::TensorShape(
+                        src_md->dims[0], src_md->dims[1]);
+                acl_tensor_shape_out = arm_compute::TensorShape(
+                        dst_md->padded_dims[0], dst_md->padded_dims[1]);
+
+                // f32 to bf16 reorder
+            } else if (src_md->data_type == data_type::f32
+                    && dst_md->data_type == data_type::f32) {
+
+                auto src_tag = memory_desc_matches_one_of_tag(
+                        *src_md, format_tag::ba, format_tag::cdba);
+                ACL_CHECK_SUPPORT(utils::one_of(format_tag::undef, src_tag),
+                        "Only ba and cdba source formats supported");
+
+                // Switch for 2 or 4 dim tensors
+                switch (src_md->ndims) {
+                    // Currently for Ab4a and Ab8a
+                    case 2: {
+                        if (dst_md->dims[0] == 1 || dst_md->dims[1] == 1) {
                             return status::unimplemented;
                         }
-                        if(dst_dim_1_stride == 4){
+
+                        auto dst_tag = memory_desc_matches_one_of_tag(
+                                *dst_md, format_tag::Ab4a, format_tag::Ab8a);
+                        ACL_CHECK_SUPPORT(
+                                utils::one_of(format_tag::undef, dst_tag),
+                                "Only Ab4a and Ab8a dst format supported for "
+                                "4d tensors");
+
+                        if (dst_tag == format_tag::Ab4a) {
                             // Set Dest WeightFormat
-                            _pd->app_.dst_wf = arm_compute::WeightFormat::OHWIo4;
-                            dim_0_rounded_up
-                                    = utils::rnd_up(src_md->dims[0], 4);
-                        } else {
+                            _pd->app_.dst_wf
+                                    = arm_compute::WeightFormat::OHWIo4;
+                            // Blocking for Acdb8a only supported with SVE length 256
+                        } else if (dst_tag == format_tag::Ab8a
+                                && mayiuse(sve_256)) {
                             // Set Dest WeightFormat
-                            _pd->app_.dst_wf = arm_compute::WeightFormat::OHWIo8;
-                            dim_0_rounded_up
-                                    = utils::rnd_up(src_md->dims[0], 8);
+                            _pd->app_.dst_wf
+                                    = arm_compute::WeightFormat::OHWIo8;
+                        } else {
+                            return status::unimplemented;
                         }
-                        acl_tensor_shape_in = arm_compute::TensorShape(src_md->dims[1], src_md->dims[0]);
-                        acl_tensor_shape_out = arm_compute::TensorShape(src_md->dims[1], dim_0_rounded_up);
 
+                        acl_tensor_shape_in = arm_compute::TensorShape(
+                                src_md->dims[1], src_md->dims[0]);
+                        acl_tensor_shape_out = arm_compute::TensorShape(
+                                dst_md->padded_dims[1], dst_md->padded_dims[0]);
                         break;
                     }
-                // Currently for Acdb4a and Acdb8a
-                case 4:
-                    { 
+                    // Currently supports Acdb4a and Acdb8a
+                    case 4: {
+                        // Currently only supporting AxBx1x1 cases
+                        if (dst_md->dims[2] != 1 || dst_md->dims[3] != 1) {
+                            return status::unimplemented;
+                        }
 
-                        auto dst_tag = memory_desc_matches_one_of_tag(
-                            *dst_md, format_tag::Acdb4a, format_tag::Acdb8a);
+                        if (dst_md->dims[0] == 1 || dst_md->dims[1] == 1) {
+                            return status::unimplemented;
+                        }
+
+                        auto dst_tag = memory_desc_matches_one_of_tag(*dst_md,
+                                format_tag::Acdb4a, format_tag::Acdb8a);
                         ACL_CHECK_SUPPORT(
-                            utils::one_of(format_tag::undef, dst_tag),
-                            "");
-                        if(dst_tag == format_tag::Acdb4a){
+                                utils::one_of(format_tag::undef, dst_tag),
+                                "Only Acdb4a and Acdb8a dst format supported "
+                                "for "
+                                "4d tensors");
+
+                        if (dst_tag == format_tag::Acdb4a) {
                             // Set Dest WeightFormat
-                            _pd->app_.dst_wf = arm_compute::WeightFormat::OHWIo4;
-                            dim_0_rounded_up
-                                    = utils::rnd_up(src_md->dims[0], 4);
-                        }
-                        else{
+                            _pd->app_.dst_wf
+                                    = arm_compute::WeightFormat::OHWIo4;
+                            // Blocking for Acdb8a only supported with SVE length 256
+                        } else if (dst_tag == format_tag::Acdb8a
+                                && mayiuse(sve_256)) {
                             // Set Dest WeightFormat
-                            _pd->app_.dst_wf = arm_compute::WeightFormat::OHWIo8;
-                            dim_0_rounded_up
-                                    = utils::rnd_up(src_md->dims[0], 8);
-                        }
-                        // Currently only supporting AxBx1x1 cases
-                        if(dst_md->dims[2] != 1 || dst_md->dims[3] != 1){
-                            return status::unimplemented;
-                        }
-                        if(dst_md->dims[0] == 1 || dst_md->dims[1] == 1){
+                            _pd->app_.dst_wf
+                                    = arm_compute::WeightFormat::OHWIo8;
+                        } else {
                             return status::unimplemented;
                         }
-                        acl_tensor_shape_in = arm_compute::TensorShape(src_md->dims[3], src_md->dims[2], src_md->dims[1], src_md->dims[0]);
-                        acl_tensor_shape_out = arm_compute::TensorShape(src_md->dims[3], src_md->dims[2], src_md->dims[1], dim_0_rounded_up);
+
+                        acl_tensor_shape_in = arm_compute::TensorShape(
+                                src_md->dims[3], src_md->dims[2],
+                                src_md->dims[1], src_md->dims[0]);
+                        acl_tensor_shape_out = arm_compute::TensorShape(
+                                dst_md->padded_dims[3], dst_md->padded_dims[2],
+                                dst_md->padded_dims[1], dst_md->padded_dims[0]);
                         break;
                     }
-                default:
-                    return status::unimplemented;
+                    default: return status::unimplemented;
+                }
+            } else {
+                return status::unimplemented;
             }
 
             // Choose the data layout
-            // bool is_nspc = utils::one_of(src_tag, format_tag::nhwc);
             const auto acl_layout = arm_compute::DataLayout::NCHW;
 
             // Set Source WeightFormat
             _pd->app_.src_wf = arm_compute::WeightFormat::OHWI;
 
             // Create ACL tensor infos
-            const data_type_t data_type = src_d.data_type();
-            const arm_compute::DataType acl_data_t
-                    = acl_utils::get_acl_data_t(data_type);
+            const arm_compute::DataType src_acl_data_t
+                    = acl_utils::get_acl_data_t(src_md->data_type);
             _pd->app_.src_info = arm_compute::TensorInfo(
-                        acl_tensor_shape_in, 1, acl_data_t, acl_layout);
+                    acl_tensor_shape_in, 1, src_acl_data_t, acl_layout);
+
+            const arm_compute::DataType dst_acl_data_t
+                    = acl_utils::get_acl_data_t(dst_md->data_type);
             _pd->app_.dst_info = arm_compute::TensorInfo(
-                        acl_tensor_shape_out, 1, acl_data_t, acl_layout);
+                    acl_tensor_shape_out, 1, dst_acl_data_t, acl_layout);
+
+            ACL_CHECK_VALID(arm_compute::NEReorderLayer::validate(
+                    &_pd->app_.src_info, &_pd->app_.dst_info, _pd->app_.src_wf,
+                    _pd->app_.dst_wf));
 
             // Init scratch memory, not used so 0 in this implementation
             _pd->init_scratchpad_md();
 
-            return safe_ptr_assign(*reorder_pd, _pd);
-        } // create 
+            return safe_ptr_assign(*reorder_pd, _pd.release());
+        } // create
 
         friend dnnl::impl::impl_list_item_t;
         acl_reorder_conf_t app_;
@@ -251,7 +296,6 @@ private:
     status_t execute_forward(const exec_ctx_t &ctx) const;
     const pd_t *pd() const { return (const pd_t *)primitive_t::pd().get(); }
 
-
 }; // acl_reorder_fwd_t
 
 } // namespace aarch64
diff --git a/src/cpu/platform.cpp b/src/cpu/platform.cpp
index 65b887ea21..4b65989386 100644
--- a/src/cpu/platform.cpp
+++ b/src/cpu/platform.cpp
@@ -117,6 +117,8 @@ bool has_data_type_support(data_type_t data_type) {
 #if defined(USE_CBLAS) && defined(BLAS_HAS_SBGEMM) && defined(__MMA__)
             return true;
 #endif
+#elif DNNL_AARCH64_USE_ACL
+            return arm_compute::CPUInfo::get().has_bf16();
 #else
             return false;
 #endif
@@ -144,6 +146,8 @@ bool has_training_support(data_type_t data_type) {
 #if defined(USE_CBLAS) && defined(BLAS_HAS_SBGEMM) && defined(__MMA__)
             return true;
 #endif
+#elif DNNL_AARCH64_USE_ACL
+            return arm_compute::CPUInfo::get().has_bf16();
 #else
             return false;
 #endif
diff --git a/src/cpu/reorder/cpu_reorder_regular_f32_bf16.cpp b/src/cpu/reorder/cpu_reorder_regular_f32_bf16.cpp
index d4e21d316e..2e0c4ac41a 100644
--- a/src/cpu/reorder/cpu_reorder_regular_f32_bf16.cpp
+++ b/src/cpu/reorder/cpu_reorder_regular_f32_bf16.cpp
@@ -16,6 +16,7 @@
 *******************************************************************************/
 
 #include "cpu/reorder/cpu_reorder.hpp"
+#include "cpu/aarch64/acl_reorder.hpp"
 
 namespace dnnl {
 namespace impl {
@@ -35,8 +36,10 @@ const impl_list_map_t &regular_f32_bf16_impl_list_map() {
             DNNL_NON_X64_ONLY(REG_SR_BIDIR(f32, any, bf16, nChw16c))
             DNNL_NON_X64_ONLY(REG_SR_BIDIR(f32, any, bf16, nCdhw16c))
 
+            DNNL_AARCH64_ACL_ONLY(CPU_REORDER_INSTANCE(aarch64::acl_reorder_fwd_t))
             DNNL_AARCH64_ONLY(CPU_REORDER_INSTANCE(aarch64::jit_uni_reorder_t))
 
+
             DNNL_NON_X64_ONLY(REG_SR(f32, oihw, bf16, OIhw8i16o2i, fmt_order::keep))
             DNNL_NON_X64_ONLY(REG_SR(f32, goihw, bf16, gOIhw8i16o2i, fmt_order::keep))
             DNNL_NON_X64_ONLY(REG_SR(f32, oihw, bf16, OIhw8o16i2o, fmt_order::keep))
diff --git a/tests/benchdnn/dnnl_debug_autogenerated.cpp b/tests/benchdnn/dnnl_debug_autogenerated.cpp
index 453193ba61..dfdd5ae5e7 100644
--- a/tests/benchdnn/dnnl_debug_autogenerated.cpp
+++ b/tests/benchdnn/dnnl_debug_autogenerated.cpp
@@ -125,6 +125,8 @@ dnnl_format_tag_t str2fmt_tag(const char *str) {
     CASE(abcdefghji);
     CASE(abcdefghikj);
     CASE(abcdefghijlk);
+    CASE(Ab4a);
+    CASE(Ab8a);
     CASE(Abc16a);
     CASE(ABc16a16b);
     CASE(ABc32a32b);
@@ -576,6 +578,8 @@ dnnl_format_tag_t str2fmt_tag(const char *str) {
     CASE(BA4b8a16b4a);
     CASE(aCB4c8b16c2b);
     CASE(aCB4c8b16c4b);
+    CASE(BA4b4a);
+    CASE(BA8b4a);
     CASE(BA16a16b);
     CASE(BA16a32b);
     CASE(BA16a48b);
diff --git a/tests/gtests/test_reorder.cpp b/tests/gtests/test_reorder.cpp
index 5050d12d42..6cabe6f712 100644
--- a/tests/gtests/test_reorder.cpp
+++ b/tests/gtests/test_reorder.cpp
@@ -1,5 +1,6 @@
 /*******************************************************************************
-* Copyright 2016-2022 Intel Corporation
+* Copyright 2016-2023 Intel Corporation
+* Copyright 2023 Arm Ltd. and affiliates
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -26,20 +27,26 @@
 
 namespace dnnl {
 
+using f32_bf16 = std::pair<float, bfloat16_t>;
 using f32_f32 = std::pair<float, float>;
 using s32_s32 = std::pair<int32_t, int32_t>;
 using s8_s8 = std::pair<int8_t, int8_t>;
 
+using cfg_bf16 = test_simple_params<f32_bf16>;
 using cfg_f32 = test_simple_params<f32_f32>;
 using cfg_s32 = test_simple_params<s32_s32>;
 using cfg_s8 = test_simple_params<s8_s8>;
 
+using reorder_simple_test_f32_bf16 = reorder_simple_test<f32_bf16>;
 using reorder_simple_test_f32_f32 = reorder_simple_test<f32_f32>;
 using reorder_simple_test_s32_s32 = reorder_simple_test<s32_s32>;
 using reorder_simple_test_s8_s8 = reorder_simple_test<s8_s8>;
 
 using fmt = memory::format_tag;
 
+TEST_P(reorder_simple_test_f32_bf16, TestsReorder) {
+    Test();
+}
 TEST_P(reorder_simple_test_s32_s32, TestsReorder) {
     Test();
 }
@@ -50,6 +57,16 @@ TEST_P(reorder_simple_test_s8_s8, TestsReorder) {
     Test();
 }
 
+INSTANTIATE_TEST_SUITE_P(ACLCases, reorder_simple_test_f32_bf16,
+        ::testing::Values(cfg_bf16 {fmt::ab, fmt::BA4b4a, {128, 128}},
+                cfg_bf16 {fmt::ab, fmt::BA8b4a, {128, 128}}));
+
+INSTANTIATE_TEST_SUITE_P(ACLCases, reorder_simple_test_f32_f32,
+        ::testing::Values(cfg_f32 {fmt::cdba, fmt::Acdb8a, {16, 16, 1, 1}},
+                cfg_f32 {fmt::cdba, fmt::Acdb8a, {1, 16, 1, 1}},
+                cfg_f32 {fmt::ba, fmt::Ab4a, {128, 128}},
+                cfg_f32 {fmt::ba, fmt::Ab8a, {128, 128}}));
+
 INSTANTIATE_TEST_SUITE_P(CornerCases, reorder_simple_test_f32_f32,
         ::testing::Values(cfg_f32 {fmt::nchw, fmt::nc, {2, 16, 8, 8}, true,
                                   dnnl_invalid_arguments},
@@ -106,10 +123,13 @@ CPU_INSTANTIATE_TEST_SUITE_P(PaddedWeights, reorder_simple_test_f32_f32,
                 // OIhw16i16o
                 cfg_f32 {fmt::oihw, fmt::OIhw16i16o, {17, 23, 2, 3}},
                 cfg_f32 {fmt::OIhw16i16o, fmt::oihw, {17, 23, 2, 3}},
-                cfg_f32 {fmt::oihw, fmt::OIhw16o16i, {17, 23, 2, 3}},
-                cfg_f32 {fmt::OIhw16o16i, fmt::oihw, {17, 23, 2, 3}},
                 cfg_f32 {fmt::hwio, fmt::OIhw16i16o, {17, 23, 2, 3}},
                 cfg_f32 {fmt::OIhw16i16o, fmt::hwio, {17, 23, 2, 3}},
+                // OhwI16i16o
+                cfg_f32 {fmt::oihw, fmt::OhwI16i16o, {17, 23, 2, 3}},
+                cfg_f32 {fmt::OhwI16i16o, fmt::oihw, {17, 23, 2, 3}},
+                cfg_f32 {fmt::hwio, fmt::OhwI16i16o, {17, 23, 2, 3}},
+                cfg_f32 {fmt::OhwI16i16o, fmt::hwio, {17, 23, 2, 3}},
                 // OIhw16o16i
                 cfg_f32 {fmt::oihw, fmt::OIhw16o16i, {17, 23, 2, 3}},
                 cfg_f32 {fmt::OIhw16o16i, fmt::oihw, {17, 23, 2, 3}},
@@ -140,21 +160,31 @@ CPU_INSTANTIATE_TEST_SUITE_P(PaddedWeights, reorder_simple_test_f32_f32,
                 // OIhw8i8o
                 cfg_f32 {fmt::oihw, fmt::OIhw8i8o, {17, 23, 2, 3}},
                 cfg_f32 {fmt::OIhw8i8o, fmt::oihw, {17, 23, 2, 3}},
+                cfg_f32 {fmt::hwio, fmt::OIhw8i8o, {17, 23, 2, 3}},
+                cfg_f32 {fmt::OIhw8i8o, fmt::hwio, {17, 23, 2, 3}},
+                // OIhw8o8i
                 cfg_f32 {fmt::oihw, fmt::OIhw8o8i, {17, 23, 2, 3}},
                 cfg_f32 {fmt::OIhw8o8i, fmt::oihw, {17, 23, 2, 3}},
-                cfg_f32 {fmt::hwio, fmt::OIhw8i8o, {17, 23, 2, 3}},
-                cfg_f32 {fmt::OIhw8i8o, fmt::hwio, {17, 23, 2, 3}}));
+                // OhwI8i8o
+                cfg_f32 {fmt::oihw, fmt::OhwI8i8o, {17, 23, 2, 3}},
+                cfg_f32 {fmt::OhwI8i8o, fmt::oihw, {17, 23, 2, 3}},
+                cfg_f32 {fmt::hwio, fmt::OhwI8i8o, {17, 23, 2, 3}},
+                cfg_f32 {fmt::OhwI8i8o, fmt::hwio, {17, 23, 2, 3}}));
 
 CPU_INSTANTIATE_TEST_SUITE_P(Weights_3d, reorder_simple_test_f32_f32,
         ::testing::Values(
                 cfg_f32 {fmt::oidhw, fmt::OIdhw8i8o, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::OIdhw8i8o, fmt::oidhw, {16, 24, 2, 3, 3}},
+                cfg_f32 {fmt::oidhw, fmt::OdhwI8i8o, {16, 24, 2, 3, 3}},
+                cfg_f32 {fmt::OdhwI8i8o, fmt::oidhw, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::oidhw, fmt::OIdhw8o8i, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::OIdhw8o8i, fmt::oidhw, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::oidhw, fmt::OIdhw8o4i, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::OIdhw8o4i, fmt::oidhw, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::dhwio, fmt::OIdhw8i8o, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::OIdhw8i8o, fmt::dhwio, {16, 24, 2, 3, 3}},
+                cfg_f32 {fmt::dhwio, fmt::OdhwI8i8o, {16, 24, 2, 3, 3}},
+                cfg_f32 {fmt::OdhwI8i8o, fmt::dhwio, {16, 24, 2, 3, 3}},
                 cfg_f32 {fmt::goidhw, fmt::gOdhwi8o, {2, 16, 24, 2, 2, 3}},
                 cfg_f32 {fmt::gOdhwi8o, fmt::goidhw, {2, 16, 24, 3, 2, 3}},
                 cfg_f32 {fmt::goidhw, fmt::gOIdhw8i8o, {2, 16, 24, 2, 2, 3}},
@@ -177,6 +207,11 @@ CPU_INSTANTIATE_TEST_SUITE_P(Weights_3d, reorder_simple_test_f32_f32,
                 cfg_f32 {fmt::IOdhw16o16i, fmt::dhwio, {64, 48, 2, 3, 4}},
                 cfg_f32 {fmt::OIdhw16i16o, fmt::IOdhw16o16i, {64, 48, 2, 3, 4}},
                 cfg_f32 {fmt::IOdhw16o16i, fmt::OIdhw16i16o, {64, 48, 2, 3, 4}},
+                // OdhwI16i16o
+                cfg_f32 {fmt::oidhw, fmt::OdhwI16i16o, {64, 48, 2, 3, 4}},
+                cfg_f32 {fmt::OdhwI16i16o, fmt::oidhw, {64, 48, 2, 3, 4}},
+                cfg_f32 {fmt::dhwio, fmt::OdhwI16i16o, {64, 48, 2, 3, 4}},
+                cfg_f32 {fmt::OdhwI16i16o, fmt::dhwio, {64, 48, 2, 3, 4}},
                 // gOIdhw16i16o and gIOdhw16o16i
                 cfg_f32 {fmt::goidhw, fmt::gOIdhw16i16o, {2, 64, 96, 2, 3, 4}},
                 cfg_f32 {fmt::gOIdhw16i16o, fmt::goidhw, {2, 64, 96, 2, 3, 4}},
@@ -221,6 +256,10 @@ CPU_INSTANTIATE_TEST_SUITE_P(Weights_0, reorder_simple_test_f32_f32,
                 cfg_f32 {fmt::OIhw8i8o, fmt::oihw, {32, 32, 3, 3}},
                 cfg_f32 {fmt::ihwo, fmt::OIhw8i8o, {32, 32, 3, 3}},
                 cfg_f32 {fmt::OIhw8i8o, fmt::ihwo, {32, 32, 3, 3}},
+                cfg_f32 {fmt::oihw, fmt::OhwI8i8o, {32, 32, 3, 3}},
+                cfg_f32 {fmt::OhwI8i8o, fmt::oihw, {32, 32, 3, 3}},
+                cfg_f32 {fmt::ihwo, fmt::OhwI8i8o, {32, 32, 3, 3}},
+                cfg_f32 {fmt::OhwI8i8o, fmt::ihwo, {32, 32, 3, 3}},
                 cfg_f32 {fmt::oihw, fmt::OIhw8o8i, {32, 32, 3, 3}},
                 cfg_f32 {fmt::OIhw8o8i, fmt::oihw, {32, 32, 3, 3}},
                 cfg_f32 {fmt::oihw, fmt::OIhw8o4i, {32, 32, 3, 3}},
@@ -229,6 +268,8 @@ CPU_INSTANTIATE_TEST_SUITE_P(Weights_0, reorder_simple_test_f32_f32,
                 cfg_f32 {fmt::OIhw8o8i, fmt::OIhw8i8o, {32, 32, 3, 3}},
                 cfg_f32 {fmt::hwio, fmt::OIhw8i8o, {32, 32, 3, 3}},
                 cfg_f32 {fmt::OIhw8i8o, fmt::hwio, {32, 32, 3, 3}},
+                cfg_f32 {fmt::hwio, fmt::OhwI8i8o, {32, 32, 3, 3}},
+                cfg_f32 {fmt::OhwI8i8o, fmt::hwio, {32, 32, 3, 3}},
                 cfg_f32 {fmt::goihw, fmt::hwigo, {2, 32, 32, 3, 3}},
                 cfg_f32 {fmt::hwigo, fmt::goihw, {2, 32, 32, 3, 3}},
                 cfg_f32 {fmt::goihw, fmt::gOIhw8i8o, {2, 32, 32, 3, 3}},
@@ -243,10 +284,16 @@ CPU_INSTANTIATE_TEST_SUITE_P(Weights_0, reorder_simple_test_f32_f32,
                 cfg_f32 {fmt::OIhw16i16o, fmt::oihw, {64, 64, 3, 3}},
                 cfg_f32 {fmt::ihwo, fmt::OIhw16i16o, {64, 64, 3, 3}},
                 cfg_f32 {fmt::OIhw16i16o, fmt::ihwo, {64, 64, 3, 3}},
+                cfg_f32 {fmt::oihw, fmt::OhwI16i16o, {64, 64, 3, 3}},
+                cfg_f32 {fmt::OhwI16i16o, fmt::oihw, {64, 64, 3, 3}},
+                cfg_f32 {fmt::ihwo, fmt::OhwI16i16o, {64, 64, 3, 3}},
+                cfg_f32 {fmt::OhwI16i16o, fmt::ihwo, {64, 64, 3, 3}},
                 cfg_f32 {fmt::oihw, fmt::OIhw16o16i, {64, 64, 3, 3}},
                 cfg_f32 {fmt::OIhw16o16i, fmt::oihw, {64, 64, 3, 3}},
                 cfg_f32 {fmt::hwio, fmt::OIhw16i16o, {64, 64, 3, 3}},
                 cfg_f32 {fmt::OIhw16i16o, fmt::hwio, {64, 64, 3, 3}},
+                cfg_f32 {fmt::hwio, fmt::OhwI16i16o, {64, 64, 3, 3}},
+                cfg_f32 {fmt::OhwI16i16o, fmt::hwio, {64, 64, 3, 3}},
                 cfg_f32 {fmt::goihw, fmt::gOIhw16i16o, {2, 64, 64, 3, 3}},
                 cfg_f32 {fmt::gOIhw16i16o, fmt::goihw, {2, 64, 64, 3, 3}},
                 cfg_f32 {fmt::goihw, fmt::gOIhw16o16i, {2, 64, 64, 3, 3}},
@@ -284,6 +331,8 @@ CPU_INSTANTIATE_TEST_SUITE_P(Weights_IOhw16o16i, reorder_simple_test_f32_f32,
                 cfg_f32 {fmt::IOhw16o16i, fmt::oihw, {64, 64, 3, 3}},
                 cfg_f32 {fmt::OIhw16i16o, fmt::IOhw16o16i, {64, 64, 3, 3}},
                 cfg_f32 {fmt::IOhw16o16i, fmt::OIhw16i16o, {64, 64, 3, 3}},
+                cfg_f32 {fmt::OhwI16i16o, fmt::IOhw16o16i, {64, 64, 3, 3}},
+                cfg_f32 {fmt::IOhw16o16i, fmt::OhwI16i16o, {64, 64, 3, 3}},
                 cfg_f32 {fmt::goihw, fmt::gOIhw16o16i, {2, 64, 64, 3, 3}},
                 cfg_f32 {fmt::gIOhw16o16i, fmt::goihw, {2, 64, 64, 3, 3}},
                 cfg_f32 {fmt::gOIhw16i16o, fmt::gIOhw16o16i, {2, 64, 64, 3, 3}},
@@ -297,6 +346,8 @@ CPU_INSTANTIATE_TEST_SUITE_P(Simple, reorder_simple_test_s32_s32,
 CPU_INSTANTIATE_TEST_SUITE_P(Simple, reorder_simple_test_s8_s8,
         ::testing::Values(cfg_s8 {fmt::oihw, fmt::OIhw4i16o4i, {64, 64, 3, 3}},
                 cfg_s8 {fmt::OIhw4i16o4i, fmt::oihw, {64, 64, 3, 3}},
+                cfg_s8 {fmt::oihw, fmt::OhwI4i16o4i, {64, 64, 3, 3}},
+                cfg_s8 {fmt::OhwI4i16o4i, fmt::oihw, {64, 64, 3, 3}},
                 cfg_s8 {fmt::goihw, fmt::gOIhw4i16o4i, {2, 64, 64, 3, 3}},
                 cfg_s8 {fmt::gOIhw4i16o4i, fmt::goihw, {2, 64, 64, 3, 3}}));
 
@@ -330,16 +381,21 @@ GPU_INSTANTIATE_TEST_SUITE_P(Weights, reorder_simple_test_f32_f32,
                 cfg_f32 {fmt::OIhw16o16i, fmt::IOhw16i16o, {32, 48, 2, 3}},
                 cfg_f32 {fmt::gOIhw16o16i, fmt::gIOhw16i16o, {2, 64, 32, 3, 2}},
                 cfg_f32 {fmt::oidhw, fmt::OIdhw16i16o, {64, 32, 3, 9, 5}},
+                cfg_f32 {fmt::oidhw, fmt::OdhwI16i16o, {64, 32, 3, 9, 5}},
                 cfg_f32 {
                         fmt::goidhw, fmt::gOIdhw16i16o, {2, 32, 64, 2, 2, 7}}));
 
 GPU_INSTANTIATE_TEST_SUITE_P(weights_1D, reorder_simple_test_f32_f32,
         ::testing::Values(cfg_f32 {fmt::oiw, fmt::OIw8i16o2i, {32, 48, 7}},
                 cfg_f32 {fmt::OIw8i16o2i, fmt::oiw, {32, 48, 7}},
+                cfg_f32 {fmt::oiw, fmt::OwI8i16o2i, {32, 48, 7}},
+                cfg_f32 {fmt::OwI8i16o2i, fmt::oiw, {32, 48, 7}},
                 cfg_f32 {fmt::goiw, fmt::gOIw8i16o2i, {8, 32, 48, 7}},
                 cfg_f32 {fmt::gOIw8i16o2i, fmt::goiw, {8, 32, 48, 7}},
                 cfg_f32 {fmt::oiw, fmt::OIw16i16o, {32, 48, 7}},
+                cfg_f32 {fmt::oiw, fmt::OwI16i16o, {32, 48, 7}},
                 cfg_f32 {fmt::OIw16i16o, fmt::oiw, {32, 48, 7}},
+                cfg_f32 {fmt::OwI16i16o, fmt::oiw, {32, 48, 7}},
                 cfg_f32 {fmt::oiw, fmt::OIw8o4i, {32, 48, 7}},
                 cfg_f32 {fmt::OIw8o4i, fmt::oiw, {32, 48, 7}},
                 cfg_f32 {fmt::goiw, fmt::gOIw16i16o, {8, 32, 48, 7}},
-- 
2.25.1

